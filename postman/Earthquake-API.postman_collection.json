{
	"info": {
		"_postman_id": "earthquake-api-collection",
		"name": "Earthquake Data Platform API",
		"description": "Collection for testing the Earthquake Data Platform API endpoints on LocalStack.\n\nIncludes:\n- Ingestion endpoint (POST /ingest/recent)\n- Query endpoint (GET /earthquakes) with filters and pagination\n\nPrerequisites:\n1. Run `pnpm local:up` to start LocalStack\n2. Run `pnpm infra:deploy` to deploy CDK stack\n3. Set {{baseUrl}} environment variable to your API Gateway URL",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Ingestion",
			"item": [
				{
					"name": "Ingest Recent Earthquakes",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response has required fields', function () {",
									"    const jsonData = pm.response.json();",
									"    pm.expect(jsonData).to.have.property('fetched');",
									"    pm.expect(jsonData).to.have.property('upserted');",
									"    pm.expect(jsonData).to.have.property('skipped');",
									"    pm.expect(jsonData).to.have.property('retries');",
									"});",
									"",
									"pm.test('Fetched count is 100', function () {",
									"    const jsonData = pm.response.json();",
									"    pm.expect(jsonData.fetched).to.eql(100);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/ingest/recent",
							"host": ["{{baseUrl}}"],
							"path": ["ingest", "recent"]
						},
						"description": "Fetches the 100 most recent earthquakes from USGS and stores them in DynamoDB.\n\nIdempotent - running multiple times will skip duplicates."
					},
					"response": [
						{
							"name": "Success - First Run",
							"originalRequest": {
								"method": "POST",
								"url": {
									"raw": "{{baseUrl}}/ingest/recent",
									"host": ["{{baseUrl}}"],
									"path": ["ingest", "recent"]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"body": "{\n  \"fetched\": 100,\n  \"upserted\": 100,\n  \"skipped\": 0,\n  \"retries\": 0\n}"
						},
						{
							"name": "Success - Subsequent Run",
							"originalRequest": {
								"method": "POST",
								"url": {
									"raw": "{{baseUrl}}/ingest/recent",
									"host": ["{{baseUrl}}"],
									"path": ["ingest", "recent"]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"body": "{\n  \"fetched\": 100,\n  \"upserted\": 15,\n  \"skipped\": 85,\n  \"retries\": 0\n}"
						}
					]
				}
			]
		},
		{
			"name": "Query",
			"item": [
				{
					"name": "Query Earthquakes - ISO-8601 Format",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response has items array', function () {",
									"    const jsonData = pm.response.json();",
									"    pm.expect(jsonData).to.have.property('items');",
									"    pm.expect(jsonData.items).to.be.an('array');",
									"});",
									"",
									"pm.test('All events meet magnitude threshold', function () {",
									"    const jsonData = pm.response.json();",
									"    const minMag = parseFloat(pm.request.url.query.get('minmagnitude'));",
									"    jsonData.items.forEach(item => {",
									"        pm.expect(item.mag).to.be.at.least(minMag);",
									"    });",
									"});",
									"",
									"// Save nextToken for pagination",
									"if (pm.response.json().nextToken) {",
									"    pm.environment.set('nextToken', pm.response.json().nextToken);",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-12T00:00:00Z&endtime=2025-10-19T23:59:59Z&minmagnitude=3.0&pageSize=50",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-12T00:00:00Z",
									"description": "Start of time window (ISO-8601)"
								},
								{
									"key": "endtime",
									"value": "2025-10-19T23:59:59Z",
									"description": "End of time window (ISO-8601)"
								},
								{
									"key": "minmagnitude",
									"value": "3.0",
									"description": "Minimum magnitude threshold"
								},
								{
									"key": "pageSize",
									"value": "50",
									"description": "Results per page (1-100, default 50)"
								}
							]
						},
						"description": "Query earthquakes using ISO-8601 formatted timestamps.\n\nReturns events within time window with magnitude >= threshold."
					},
					"response": []
				},
				{
					"name": "Query Earthquakes - Epoch Milliseconds",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Events are ordered newest first', function () {",
									"    const jsonData = pm.response.json();",
									"    if (jsonData.items.length > 1) {",
									"        for (let i = 0; i < jsonData.items.length - 1; i++) {",
									"            pm.expect(jsonData.items[i].eventTsMs).to.be.at.least(jsonData.items[i + 1].eventTsMs);",
									"        }",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=1728691200000&endtime=1729382399000&minmagnitude=4.0&pageSize=25",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "1728691200000",
									"description": "Start of time window (epoch ms: 2025-10-12 00:00:00 UTC)"
								},
								{
									"key": "endtime",
									"value": "1729382399000",
									"description": "End of time window (epoch ms: 2025-10-19 23:59:59 UTC)"
								},
								{
									"key": "minmagnitude",
									"value": "4.0",
									"description": "Minimum magnitude threshold"
								},
								{
									"key": "pageSize",
									"value": "25",
									"description": "Results per page"
								}
							]
						},
						"description": "Query earthquakes using Unix epoch millisecond timestamps.\n\nFunctionally identical to ISO-8601 format, accepts numeric timestamps."
					},
					"response": []
				},
				{
					"name": "Query Earthquakes - Next Page (Pagination)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response contains items', function () {",
									"    const jsonData = pm.response.json();",
									"    pm.expect(jsonData.items).to.be.an('array');",
									"});",
									"",
									"// Update nextToken for subsequent pages",
									"if (pm.response.json().nextToken) {",
									"    pm.environment.set('nextToken', pm.response.json().nextToken);",
									"} else {",
									"    console.log('Last page reached - no nextToken returned');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"if (!pm.environment.get('nextToken')) {",
									"    console.warn('No nextToken found. Run \"Query Earthquakes\" request first to generate a cursor.');",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-12T00:00:00Z&endtime=2025-10-19T23:59:59Z&minmagnitude=3.0&pageSize=50&nextToken={{nextToken}}",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-12T00:00:00Z",
									"description": "Must match original query"
								},
								{
									"key": "endtime",
									"value": "2025-10-19T23:59:59Z",
									"description": "Must match original query"
								},
								{
									"key": "minmagnitude",
									"value": "3.0",
									"description": "Must match original query"
								},
								{
									"key": "pageSize",
									"value": "50",
									"description": "Must match original query"
								},
								{
									"key": "nextToken",
									"value": "{{nextToken}}",
									"description": "Cursor from previous response"
								}
							]
						},
						"description": "Retrieve the next page of results using the nextToken from the previous response.\n\n⚠️ All query parameters (starttime, endtime, minmagnitude, pageSize) must match the original request or you'll get a VALIDATION_ERROR.\n\nRun \"Query Earthquakes\" first to populate the {{nextToken}} variable."
					},
					"response": []
				},
				{
					"name": "Query Earthquakes - Large Magnitude Only",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-01T00:00:00Z&endtime=2025-10-19T23:59:59Z&minmagnitude=5.5&pageSize=100",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-01T00:00:00Z"
								},
								{
									"key": "endtime",
									"value": "2025-10-19T23:59:59Z"
								},
								{
									"key": "minmagnitude",
									"value": "5.5",
									"description": "Only significant earthquakes"
								},
								{
									"key": "pageSize",
									"value": "100",
									"description": "Maximum page size"
								}
							]
						},
						"description": "Filter for significant earthquakes (magnitude >= 5.5) with maximum page size."
					},
					"response": []
				},
				{
					"name": "Query Earthquakes - Last 7 Days",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Calculate timestamps for last 7 days",
									"const now = new Date();",
									"const sevenDaysAgo = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));",
									"",
									"pm.environment.set('endtime', now.toISOString());",
									"pm.environment.set('starttime', sevenDaysAgo.toISOString());",
									"",
									"console.log('Time range:', sevenDaysAgo.toISOString(), 'to', now.toISOString());"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime={{starttime}}&endtime={{endtime}}&minmagnitude=2.5&pageSize=50",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "{{starttime}}",
									"description": "Auto-calculated: 7 days ago"
								},
								{
									"key": "endtime",
									"value": "{{endtime}}",
									"description": "Auto-calculated: now"
								},
								{
									"key": "minmagnitude",
									"value": "2.5"
								},
								{
									"key": "pageSize",
									"value": "50"
								}
							]
						},
						"description": "Dynamic query for earthquakes in the last 7 days.\n\nPre-request script automatically calculates starttime and endtime."
					},
					"response": []
				}
			]
		},
		{
			"name": "Filter & Pagination Validation",
			"item": [
				{
					"name": "Validate PageSize Limits",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Returned items count respects pageSize', function () {",
									"    const jsonData = pm.response.json();",
									"    const requestedPageSize = parseInt(pm.request.url.query.get('pageSize'));",
									"    pm.expect(jsonData.items).to.be.an('array');",
									"    pm.expect(jsonData.items.length).to.be.at.most(requestedPageSize);",
									"});",
									"",
									"pm.test('All items are valid earthquake objects', function () {",
									"    const jsonData = pm.response.json();",
									"    jsonData.items.forEach(item => {",
									"        pm.expect(item).to.have.property('eventId');",
									"        pm.expect(item).to.have.property('mag');",
									"        pm.expect(item).to.have.property('place');",
									"        pm.expect(item).to.have.property('eventTsMs');",
									"    });",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-01T00:00:00Z&endtime=2025-10-22T23:59:59Z&minmagnitude=2.0&pageSize=10",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-01T00:00:00Z"
								},
								{
									"key": "endtime",
									"value": "2025-10-22T23:59:59Z"
								},
								{
									"key": "minmagnitude",
									"value": "2.0"
								},
								{
									"key": "pageSize",
									"value": "10",
									"description": "Small page to test limit enforcement"
								}
							]
						},
						"description": "Validates that the API respects pageSize parameter and returns at most the requested number of items."
					},
					"response": []
				},
				{
					"name": "Validate Magnitude Filter",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('All earthquakes meet minimum magnitude', function () {",
									"    const jsonData = pm.response.json();",
									"    const minMag = parseFloat(pm.request.url.query.get('minmagnitude'));",
									"    ",
									"    jsonData.items.forEach((item, index) => {",
									"        pm.expect(item.mag, `Item ${index} (${item.id}) magnitude`).to.be.at.least(minMag);",
									"    });",
									"});",
									"",
									"pm.test('Magnitude values are numeric', function () {",
									"    const jsonData = pm.response.json();",
									"    jsonData.items.forEach(item => {",
									"        pm.expect(typeof item.mag).to.eql('number');",
									"        pm.expect(item.mag).to.not.be.NaN;",
									"    });",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-01T00:00:00Z&endtime=2025-10-22T23:59:59Z&minmagnitude=4.5&pageSize=50",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-01T00:00:00Z"
								},
								{
									"key": "endtime",
									"value": "2025-10-22T23:59:59Z"
								},
								{
									"key": "minmagnitude",
									"value": "4.5",
									"description": "Filter for significant earthquakes"
								},
								{
									"key": "pageSize",
									"value": "50"
								}
							]
						},
						"description": "Validates that all returned earthquakes meet or exceed the minmagnitude threshold."
					},
					"response": []
				},
				{
					"name": "Validate Time Range Filter",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Calculate 7-day window",
									"const now = new Date();",
									"const sevenDaysAgo = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));",
									"",
									"const startMs = sevenDaysAgo.getTime();",
									"const endMs = now.getTime();",
									"",
									"pm.environment.set('testStartMs', startMs);",
									"pm.environment.set('testEndMs', endMs);",
									"pm.environment.set('testStartISO', sevenDaysAgo.toISOString());",
									"pm.environment.set('testEndISO', now.toISOString());"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('All earthquakes fall within time range', function () {",
									"    const jsonData = pm.response.json();",
									"    const startMs = parseInt(pm.environment.get('testStartMs'));",
									"    const endMs = parseInt(pm.environment.get('testEndMs'));",
									"    ",
									"    jsonData.items.forEach((item, index) => {",
									"        pm.expect(item.eventTsMs, `Item ${index} timestamp`).to.be.at.least(startMs);",
									"        pm.expect(item.eventTsMs, `Item ${index} timestamp`).to.be.at.most(endMs);",
									"    });",
									"});",
									"",
									"pm.test('Timestamps are valid epoch milliseconds', function () {",
									"    const jsonData = pm.response.json();",
									"    const now = Date.now();",
									"    const oneYearAgo = now - (365 * 24 * 60 * 60 * 1000);",
									"    ",
									"    jsonData.items.forEach(item => {",
									"        pm.expect(item.eventTsMs).to.be.a('number');",
									"        pm.expect(item.eventTsMs).to.be.at.least(oneYearAgo);",
									"        pm.expect(item.eventTsMs).to.be.at.most(now + 60000);",
									"    });",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime={{testStartISO}}&endtime={{testEndISO}}&minmagnitude=2.5&pageSize=50",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "{{testStartISO}}",
									"description": "Dynamic: 7 days ago"
								},
								{
									"key": "endtime",
									"value": "{{testEndISO}}",
									"description": "Dynamic: now"
								},
								{
									"key": "minmagnitude",
									"value": "2.5"
								},
								{
									"key": "pageSize",
									"value": "50"
								}
							]
						},
						"description": "Validates that all returned earthquakes fall within the specified time range. Uses dynamic timestamps to ensure test validity."
					},
					"response": []
				},
				{
					"name": "Validate Chronological Ordering",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Results are ordered newest to oldest', function () {",
									"    const jsonData = pm.response.json();",
									"    ",
									"    if (jsonData.items.length < 2) {",
									"        console.log('Less than 2 items, skipping order check');",
									"        return;",
									"    }",
									"    ",
									"    for (let i = 0; i < jsonData.items.length - 1; i++) {",
									"        const current = jsonData.items[i].eventTsMs;",
									"        const next = jsonData.items[i + 1].eventTsMs;",
									"        pm.expect(current, `Item ${i} vs ${i+1}`).to.be.at.least(next);",
									"    }",
									"});",
									"",
									"pm.test('ISO timestamps match epoch milliseconds', function () {",
									"    const jsonData = pm.response.json();",
									"    ",
									"    jsonData.items.forEach((item, index) => {",
									"        if (item.time) {",
									"            const parsedMs = new Date(item.time).getTime();",
									"            pm.expect(parsedMs, `Item ${index} timestamp consistency`).to.eql(item.eventTsMs);",
									"        }",
									"    });",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-01T00:00:00Z&endtime=2025-10-22T23:59:59Z&minmagnitude=3.0&pageSize=50",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-01T00:00:00Z"
								},
								{
									"key": "endtime",
									"value": "2025-10-22T23:59:59Z"
								},
								{
									"key": "minmagnitude",
									"value": "3.0"
								},
								{
									"key": "pageSize",
									"value": "50"
								}
							]
						},
						"description": "Validates that results are ordered chronologically (newest first) and timestamp formats are consistent."
					},
					"response": []
				},
				{
					"name": "Validate Pagination Consistency",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Page 1: Has expected structure', function () {",
									"    const jsonData = pm.response.json();",
									"    pm.expect(jsonData).to.have.property('items');",
									"    pm.expect(jsonData.items).to.be.an('array');",
									"});",
									"",
									"pm.test('Page 1: Items match pageSize or less', function () {",
									"    const jsonData = pm.response.json();",
									"    const pageSize = parseInt(pm.request.url.query.get('pageSize'));",
									"    pm.expect(jsonData.items.length).to.be.at.most(pageSize);",
									"});",
									"",
									"// Store first page data for comparison with page 2",
									"const response = pm.response.json();",
									"if (response.items.length > 0) {",
									"    pm.environment.set('page1_firstId', response.items[0].eventId);",
									"    pm.environment.set('page1_lastId', response.items[response.items.length - 1].eventId);",
									"    pm.environment.set('page1_count', response.items.length);",
									"}",
									"",
									"if (response.nextToken) {",
									"    pm.environment.set('nextToken', response.nextToken);",
									"    pm.test('NextToken is present for pagination', function () {",
									"        pm.expect(response.nextToken).to.be.a('string');",
									"        pm.expect(response.nextToken.length).to.be.greaterThan(0);",
									"    });",
									"} else {",
									"    pm.test('No nextToken - all results fit in one page', function () {",
									"        console.log('Dataset smaller than pageSize');",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-01T00:00:00Z&endtime=2025-10-22T23:59:59Z&minmagnitude=2.0&pageSize=15",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-01T00:00:00Z"
								},
								{
									"key": "endtime",
									"value": "2025-10-22T23:59:59Z"
								},
								{
									"key": "minmagnitude",
									"value": "2.0"
								},
								{
									"key": "pageSize",
									"value": "15",
									"description": "Small page to force pagination"
								}
							]
						},
						"description": "First page: validates structure and stores nextToken for subsequent page test."
					},
					"response": []
				},
				{
					"name": "Validate Pagination Page 2",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const token = pm.environment.get('nextToken');",
									"",
									"if (!token) {",
									"    pm.test('Skipped - no nextToken from page 1', function () {",
									"        console.log('Previous query returned all results in one page');",
									"    });",
									"    return;",
									"}",
									"",
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Page 2: Has items', function () {",
									"    const jsonData = pm.response.json();",
									"    pm.expect(jsonData.items).to.be.an('array');",
									"});",
									"",
									"pm.test('Page 2: No duplicate IDs from page 1', function () {",
									"    const jsonData = pm.response.json();",
									"    const page1FirstId = pm.environment.get('page1_firstId');",
									"    const page1LastId = pm.environment.get('page1_lastId');",
									"    ",
									"    jsonData.items.forEach(item => {",
									"        pm.expect(item.eventId, 'ID should not appear in page 1').to.not.eql(page1FirstId);",
									"        pm.expect(item.eventId, 'ID should not appear in page 1').to.not.eql(page1LastId);",
									"    });",
									"});",
									"",
									"pm.test('Page 2: Items still meet filter criteria', function () {",
									"    const jsonData = pm.response.json();",
									"    const minMag = parseFloat(pm.request.url.query.get('minmagnitude'));",
									"    ",
									"    jsonData.items.forEach(item => {",
									"        pm.expect(item.mag).to.be.at.least(minMag);",
									"    });",
									"});",
									"",
									"pm.test('Page 2: Chronological order maintained', function () {",
									"    const jsonData = pm.response.json();",
									"    ",
									"    if (jsonData.items.length < 2) return;",
									"    ",
									"    for (let i = 0; i < jsonData.items.length - 1; i++) {",
									"        pm.expect(jsonData.items[i].eventTsMs).to.be.at.least(jsonData.items[i + 1].eventTsMs);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-01T00:00:00Z&endtime=2025-10-22T23:59:59Z&minmagnitude=2.0&pageSize=15&nextToken={{nextToken}}",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-01T00:00:00Z"
								},
								{
									"key": "endtime",
									"value": "2025-10-22T23:59:59Z"
								},
								{
									"key": "minmagnitude",
									"value": "2.0"
								},
								{
									"key": "pageSize",
									"value": "15"
								},
								{
									"key": "nextToken",
									"value": "{{nextToken}}",
									"description": "Cursor from page 1"
								}
							]
						},
						"description": "Second page: validates no duplicate items appear and filters still apply across pagination."
					},
					"response": []
				},
				{
					"name": "Validate Combined Filters",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Set up a narrow time window (last 48 hours)",
									"const now = new Date();",
									"const twoDaysAgo = new Date(now.getTime() - (48 * 60 * 60 * 1000));",
									"",
									"pm.environment.set('narrowStartMs', twoDaysAgo.getTime());",
									"pm.environment.set('narrowEndMs', now.getTime());",
									"pm.environment.set('narrowStartISO', twoDaysAgo.toISOString());",
									"pm.environment.set('narrowEndISO', now.toISOString());"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"const jsonData = pm.response.json();",
									"const minMag = parseFloat(pm.request.url.query.get('minmagnitude'));",
									"const pageSize = parseInt(pm.request.url.query.get('pageSize'));",
									"const startMs = parseInt(pm.environment.get('narrowStartMs'));",
									"const endMs = parseInt(pm.environment.get('narrowEndMs'));",
									"",
									"pm.test('All filters applied: magnitude', function () {",
									"    jsonData.items.forEach(item => {",
									"        pm.expect(item.mag).to.be.at.least(minMag);",
									"    });",
									"});",
									"",
									"pm.test('All filters applied: time range', function () {",
									"    jsonData.items.forEach(item => {",
									"        pm.expect(item.eventTsMs).to.be.at.least(startMs);",
									"        pm.expect(item.eventTsMs).to.be.at.most(endMs);",
									"    });",
									"});",
									"",
									"pm.test('All filters applied: page size', function () {",
									"    pm.expect(jsonData.items.length).to.be.at.most(pageSize);",
									"});",
									"",
									"pm.test('All filters applied: chronological order', function () {",
									"    if (jsonData.items.length < 2) return;",
									"    ",
									"    for (let i = 0; i < jsonData.items.length - 1; i++) {",
									"        pm.expect(jsonData.items[i].eventTsMs).to.be.at.least(jsonData.items[i + 1].eventTsMs);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime={{narrowStartISO}}&endtime={{narrowEndISO}}&minmagnitude=3.5&pageSize=20",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "{{narrowStartISO}}",
									"description": "Dynamic: 48 hours ago"
								},
								{
									"key": "endtime",
									"value": "{{narrowEndISO}}",
									"description": "Dynamic: now"
								},
								{
									"key": "minmagnitude",
									"value": "3.5",
									"description": "Moderate magnitude threshold"
								},
								{
									"key": "pageSize",
									"value": "20"
								}
							]
						},
						"description": "Validates that all filters (time range, magnitude, page size, ordering) work correctly together."
					},
					"response": []
				}
			],
			"description": "Comprehensive validation tests for filters and pagination that work with dynamic data."
		},
		{
			"name": "Validation Tests",
			"item": [
				{
					"name": "Invalid - Missing Required Parameter",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 400', function () {",
									"    pm.response.to.have.status(400);",
									"});",
									"",
									"pm.test('Error code is VALIDATION_ERROR', function () {",
									"    const jsonData = pm.response.json();",
									"    pm.expect(jsonData.error).to.eql('VALIDATION_ERROR');",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-12T00:00:00Z&endtime=2025-10-19T23:59:59Z",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-12T00:00:00Z"
								},
								{
									"key": "endtime",
									"value": "2025-10-19T23:59:59Z"
								}
							]
						},
						"description": "Missing required 'minmagnitude' parameter. Should return 400."
					},
					"response": []
				},
				{
					"name": "Invalid - Negative Magnitude",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 400', function () {",
									"    pm.response.to.have.status(400);",
									"});",
									"",
									"pm.test('Error is VALIDATION_ERROR', function () {",
									"    pm.expect(pm.response.json().error).to.eql('VALIDATION_ERROR');",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-12T00:00:00Z&endtime=2025-10-19T23:59:59Z&minmagnitude=-5.0",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-12T00:00:00Z"
								},
								{
									"key": "endtime",
									"value": "2025-10-19T23:59:59Z"
								},
								{
									"key": "minmagnitude",
									"value": "-5.0",
									"description": "Invalid: below minimum of -2.0"
								}
							]
						},
						"description": "Magnitude below allowed minimum (-2.0). Should return 400."
					},
					"response": []
				},
				{
					"name": "Invalid - Page Size Exceeds Maximum",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 400', function () {",
									"    pm.response.to.have.status(400);",
									"});",
									"",
									"pm.test('Error code is VALIDATION_ERROR', function () {",
									"    const jsonData = pm.response.json();",
									"    pm.expect(jsonData.error).to.eql('VALIDATION_ERROR');",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-12T00:00:00Z&endtime=2025-10-19T23:59:59Z&minmagnitude=3.0&pageSize=150",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-12T00:00:00Z"
								},
								{
									"key": "endtime",
									"value": "2025-10-19T23:59:59Z"
								},
								{
									"key": "minmagnitude",
									"value": "3.0"
								},
								{
									"key": "pageSize",
									"value": "150",
									"description": "Invalid: exceeds maximum of 100"
								}
							]
						},
						"description": "Page size exceeds maximum (100). Should return 400."
					},
					"response": []
				},
				{
					"name": "Invalid - Inverted Time Range",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 400', function () {",
									"    pm.response.to.have.status(400);",
									"});",
									"",
									"pm.test('Error code is VALIDATION_ERROR', function () {",
									"    const jsonData = pm.response.json();",
									"    pm.expect(jsonData.error).to.eql('VALIDATION_ERROR');",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-19T00:00:00Z&endtime=2025-10-12T00:00:00Z&minmagnitude=3.0",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-19T00:00:00Z",
									"description": "After endtime (invalid)"
								},
								{
									"key": "endtime",
									"value": "2025-10-12T00:00:00Z",
									"description": "Before starttime (invalid)"
								},
								{
									"key": "minmagnitude",
									"value": "3.0"
								}
							]
						},
						"description": "endtime is before starttime. Should return 400."
					},
					"response": []
				},
				{
					"name": "Invalid - Tampered Next Token",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 400', function () {",
									"    pm.response.to.have.status(400);",
									"});",
									"",
									"pm.test('Error code is VALIDATION_ERROR', function () {",
									"    const jsonData = pm.response.json();",
									"    pm.expect(jsonData.error).to.eql('VALIDATION_ERROR');",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/earthquakes?starttime=2025-10-12T00:00:00Z&endtime=2025-10-19T23:59:59Z&minmagnitude=3.0&nextToken=TAMPERED_TOKEN_12345",
							"host": ["{{baseUrl}}"],
							"path": ["earthquakes"],
							"query": [
								{
									"key": "starttime",
									"value": "2025-10-12T00:00:00Z"
								},
								{
									"key": "endtime",
									"value": "2025-10-19T23:59:59Z"
								},
								{
									"key": "minmagnitude",
									"value": "3.0"
								},
								{
									"key": "nextToken",
									"value": "TAMPERED_TOKEN_12345",
									"description": "Invalid/tampered token"
								}
							]
						},
						"description": "Tampered or invalid nextToken. Should return 400 with signature verification error."
					},
					"response": []
				}
			]
		},
		{
			"name": "Observability",
			"item": [
				{
					"name": "Query Request Logs (Table PK)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Logs query uses base table keys', function () {",
									"    const requestBody = JSON.parse(pm.request.body.raw);",
									"    pm.expect(requestBody.KeyConditionExpression).to.eql('pk = :pk');",
									"});",
									"",
									"const body = pm.response.json();",
									"if (!body.Items || body.Items.length === 0) {",
									"    console.warn('No log items returned. Ensure a recent query ran or adjust {{logPartition}}.');",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-amz-json-1.0"
							},
							{
								"key": "X-Amz-Target",
								"value": "DynamoDB_20120810.Query"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"TableName\": \"earthquake-events\",\n  \"KeyConditionExpression\": \"pk = :pk\",\n  \"ExpressionAttributeValues\": {\n    \":pk\": { \"S\": \"{{logPartition}}\" }\n  },\n  \"ScanIndexForward\": false,\n  \"Limit\": 20\n}"
						},
						"url": {
							"raw": "{{dynamoUrl}}",
							"host": ["{{dynamoUrl}}"]
						},
						"description": "Queries request-log items directly by the base table partition key (`pk = \"LOG#<YYYYMMDD>\"`).\n\nThis reflects the current implementation where logs are NOT written to the TimeOrderedIndex GSI, so GSI queries will return zero rows until the data model is updated."
					},
					"response": []
				},
				{
					"name": "Query Request Logs (TimeOrderedIndex GSI)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Logs query targets TimeOrderedIndex', function () {",
									"    const requestBody = JSON.parse(pm.request.body.raw);",
									"    pm.expect(requestBody.IndexName).to.eql('TimeOrderedIndex');",
									"    pm.expect(requestBody.KeyConditionExpression).to.include('gsi1pk = :pk');",
									"});",
									"",
									"const body = pm.response.json();",
									"if (!body.Items || body.Items.length === 0) {",
									"    console.warn('No items returned from GSI. Ensure new logs were written after gsi1pk/gsi1sk deployment.');",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-amz-json-1.0"
							},
							{
								"key": "X-Amz-Target",
								"value": "DynamoDB_20120810.Query"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"TableName\": \"earthquake-events\",\n  \"IndexName\": \"TimeOrderedIndex\",\n  \"KeyConditionExpression\": \"gsi1pk = :pk\",\n  \"ExpressionAttributeValues\": {\n    \":pk\": { \"S\": \"{{logPartition}}\" }\n  },\n  \"ScanIndexForward\": false,\n  \"Limit\": 20\n}"
						},
						"url": {
							"raw": "{{dynamoUrl}}",
							"host": ["{{dynamoUrl}}"]
						},
						"description": "Queries the TimeOrderedIndex GSI for request-log items. Requires logs to include `gsi1pk`/`gsi1sk`, which the query Lambda now writes. If this returns no items, ingest/query fresh requests to seed new logs."
					},
					"response": []
				}
			],
			"description": "Operational helpers for inspecting DynamoDB-backed request logs using the schema that is currently deployed."
		}
	],
	"variable": [
		{
			"key": "baseUrl",
			"value": "https://{{apiId}}.execute-api.localhost.localstack.cloud:4566/local",
			"type": "string"
		},
		{
			"key": "apiId",
			"value": "52zmrdv1g3",
			"type": "string"
		},
		{
			"key": "dynamoUrl",
			"value": "http://localhost:4566",
			"type": "string"
		},
		{
			"key": "nextToken",
			"value": "",
			"type": "string"
		},
		{
			"key": "starttime",
			"value": "",
			"type": "string"
		},
		{
			"key": "endtime",
			"value": "",
			"type": "string"
		},
		{
			"key": "logPartition",
			"value": "LOG#20251019",
			"type": "string"
		}
	]
}
